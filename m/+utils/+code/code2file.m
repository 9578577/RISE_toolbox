function code2file(xcell,fname)

default_output_name='out_';

output_list=default_output_name;

if iscell(xcell)
    [xout,input_list]=main_engine();
    xout=[{[default_output_name,'=[']};xout;{'];'}];
elseif isstruct(xcell)
    derivative_fields={'size','functions','map','partitions'};%,'maxcols','nnz_derivs'
    eval_fields={'code','argins','argouts'};
    if all(isfield(xcell,derivative_fields))
        [xout,input_list]=derivative_engine();
    elseif all(isfield(xcell,eval_fields))
        [xout,input_list]=eval_engine();
    else
        % then it must be a transition matrix
        [xout,input_list]=transition_matrix_engine();
    end
elseif isa(xcell,'function_handle')
    utils.code.code2file({xcell},fname)
    return
else
    error('first input must be a cell, a structure or a function handle')
end

% write to file
%--------------
if isempty(input_list)
    input_list='(~,~,~,~,~,~,~,~,~,~)';
end

fid=fopen([fname,'.m'],'w');
fprintf(fid,'%s\n\n',['%% Code automagically generated by RISE on ',datestr(now)]);
fprintf(fid,'%s\n\n',['function ',output_list,'=',fname,input_list]);

for icod=1:numel(xout)
    if ~isempty(xout{icod})
        fprintf(fid,'%s\n\n',[xout{icod}]);
    end
end
fclose(fid);

% make the function readily available for use if necessary
%---------------------------------------------------------
rehash()

    function [xout,input_list]=transition_matrix_engine()
        xstruct=xcell;
        chain_names=fieldnames(xstruct);
        is_loose_commit=any(strcmp(chain_names,parser.loose_commit()));
        xout={[default_output_name,'=struct();'];'Q=1;'};
        if is_loose_commit
            xout=[
                xout
                {'Qinit=1;'}
                ];
        end
        for iname=1:numel(chain_names)
            chain=chain_names{iname};
            xcell={xstruct.(chain)};
            [xout_i,input_list]=main_engine();
            xout=[
                xout
                [default_output_name,'.',chain,'=',xout_i{1},';']
                {['Q=kron(Q,',default_output_name,'.',chain,');']}
                ];
            if is_loose_commit && ~strcmp(chain,parser.loose_commit())
                xout=[
                    xout
                    {['Qinit=kron(Qinit,',default_output_name,'.',chain,');']}
                    ];
            end
        end
        xout=[
            xout
            {['[',default_output_name,'.Q,retcode]=utils.code.validate_transition_matrix(Q);']}
            {'if ~retcode'}
            ];
        if ~is_loose_commit
            xout=[
                xout
                {'Qinit=Q;'}
                ];
        end
        xout=[
            xout
            {['[',default_output_name,'.Qinit,retcode]=utils.code.validate_transition_matrix(Qinit);']}
            {'end'}
            ];
        output_list=['[',output_list,',retcode]'];
    end

    function [xout,input_list]=derivative_engine()
        tmp=xcell;
        order=numel(tmp);
        xout={};
        this_output_name=default_output_name;
        % initialize a variable that subfunctions can see
        prologue={[this_output_name,'=[];']};
        different_orders={'first','second','third','fourth','fifth'};
        for io=1:order
            [xout_io,input_list]=do_one_order(io);
            if order>1
                subfunc_name=sprintf('do_%s_order',different_orders{io});
                if io==1
                    add_on={'if order ==1'};
                else
                    add_on={sprintf('elseif order ==%0.0f',io)};
                end
                prologue=[
                    prologue
                    add_on
                    {[subfunc_name,'();']}
                    ];
                xout=[
                    xout
                    {sprintf('function %s',[subfunc_name,'()'])}
                    xout_io
                    {'end'}
                    ];
            else
                xout=xout_io;
            end
        end
        if order>1
            xout=[
                prologue
                {'end'}
                {[this_output_name,'=sparse(',this_output_name,');']}
                xout
                {'end'}
                ];
        else
            xout=[
                xout
                {[this_output_name,'=sparse(',this_output_name,');']}
                {'end'}
                ];
        end
        input_list=[input_list(1),'order,',input_list(2:end)];
        
        function [xout,input_list]=do_one_order(oo)
            xcell=tmp(oo).functions;
            % output initialization
            xxx=sprintf('%s=zeros(%0.0f',this_output_name,tmp(oo).size(1));
            for icol=2:numel(tmp(oo).size)
                xxx=[xxx,',',sprintf('%0.0f',tmp(oo).size(icol))]; %#ok<*AGROW>
            end
            xxx=[xxx,');'];
            if ~isempty(xcell)
                [xout,input_list]=main_engine();
                for irows=1:size(xcell,1)
                    if ~isempty(xout{irows})
                        strcols=stringify_indexes(tmp(oo).map{irows});
                        xout{irows}=sprintf('%s(%0.0f,%s)=%s;',this_output_name,irows,strcols,xout{irows});
                    end
                end
            end
            % expand output
            xout{irows+1}=sprintf('%s=%s(:,%s);',this_output_name,this_output_name,stringify_indexes(tmp(oo).partitions));
            % add initialization
            xout=[{xxx};xout];
        end
    end

    function strcols=stringify_indexes(indexes)
        n=numel(indexes);
        strcols=sprintf('%0.0f',indexes(1));
        for ind=2:n
            strcols=[strcols,',',sprintf('%0.0f',indexes(ind))];
        end
        if n>1
            strcols=['[',strcols,']'];
        end
    end

    function [xout,input_list]=main_engine()
        n=numel(xcell);
        xout=xcell;
        entry_gate='';
        for item=1:n
            if ~isempty(xcell{item})
                if ~isa(xcell{item},'function_handle')
                    error('all elements in xcell should be function handles')
                end
                xout{item}=func2str(xcell{item});
                if isempty(entry_gate)
                    right_parenth=find(xout{item}==')',1,'first');
                    entry_gate=xout{item}(1:right_parenth);
                end
            end
        end
        xout=strrep(xout,entry_gate,'');
        input_list=strrep(entry_gate,'@','');
    end

    function [code,input_list]=eval_engine()
        input_list=cell2mat(strcat(xcell.argins,','));
        input_list=['(',input_list(1:end-1),')'];
        
        output_list=cell2mat(strcat(xcell.argouts,','));
        output_list=['[',output_list(1:end-1),']'];
        
        if isempty(xcell.code)
            code={};
        else
            code=regexp(xcell.code,';','split');
            % replace the nargout_ which is used in evaluation with nargout, which is
            % used in the normal function
            code=regexprep(code,'(?<!\w+)narg(out|in)_(?!\w+)','narg$1');
            
            code=code(:);
            code=code(cell2mat(cellfun(@(x)~isempty(x),code,'uniformOutput',false)));
            code=strcat(code,';');
        end
    end
end
